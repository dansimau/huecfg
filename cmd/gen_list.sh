#!/usr/bin/env bash
#
# Generates Go source file for a list command.
#

set -eu

for arg in "$@"; do
	varname="$(echo "$arg" | cut -f1 -d '=')"
	varval="$(echo "$arg" | cut -f2 -d '=')"

	eval "$varname='$varval'"
done

#OBJS_NAME=lights
#OBJS_TYPE="[]hue.Light"
#GET_OBJ_FUNC="GetLights()"
#OBJ_TRANSFORM_FUNC=""

if [ -z "${OBJ_TRANSFORM_FUNC:-}" ]; then
	OBJ_TRANSFORM_FUNC="${OBJS_NAME}ToGenericSlice"
fi

include_transform_func() {
	[ "$OBJ_TRANSFORM_FUNC" != "${OBJS_NAME}ToGenericSlice" ] && return 0

	cat <<EOF

func ${OBJS_NAME}ToGenericSlice(s ${OBJS_TYPE}) []interface{} {
	var res = make([]interface{}, len(s))
	for i, obj := range s {
		res[i] = obj
	}
	return res
}
EOF
}

cat <<EOF>${OBJS_NAME}_list_gen.go
// Code generated by go generate; DO NOT EDIT.
package cmd

import (
	"fmt"
	"os"
	"strings"

	"github.com/dansimau/huecfg/pkg/hue"
	"github.com/iancoleman/strcase"
)
$(include_transform_func)

type ${OBJS_NAME}ListCmd struct {
	Fields  string \`long:"fields" description:"List of fields to include"\`
	Reverse bool   \`long:"reverse" description:"Reverse sort order"\`
	Sort    string \`long:"sort" description:"Field to sort by"\`
}

func (c *${OBJS_NAME}ListCmd) Execute(args []string) error {
	if err := errorOnUnknownArgs(args); err != nil {
		return err
	}

	bridge := cmd.getHue()

	${OBJS_NAME}, err := bridge.${GET_OBJ_FUNC}
	if err != nil {
		return err
	}

	fields := ${OBJS_NAME}DefaultFields
	if c.Fields != "" {
		fields = []string{}
		for _, fieldName := range strings.Split(c.Fields, ",") {
			fields = append(fields, ${OBJS_NAME}HeaderTransform.TransformInput(fieldName))
		}
	}

	sortField := ${OBJS_NAME}DefaultSortField
	if c.Sort != "" {
		sortField = strcase.ToCamel(${OBJS_NAME}HeaderTransform.TransformInput(c.Sort))
	}

	sorted${OBJS_NAME}, err := sortByField(${OBJ_TRANSFORM_FUNC}(${OBJS_NAME}), sortField, c.Reverse)
	if err != nil {
		return err
	}

	rows := [][]string{}

	headerRow := []string{}
	for _, fieldName := range fields {
		headerRow = append(headerRow, ${OBJS_NAME}HeaderTransform.TransformOutput(fieldName))
	}
	rows = append(rows, headerRow)

	for _, light := range sorted${OBJS_NAME} {
		row := []string{}

		for _, field := range fields {
			v, err := lookupField(light, field)
			if err != nil {
				return err
			}

			row = append(row, ${OBJS_NAME}FieldTransform.TransformOutput(field, reflectValueToString(v)))
		}

		rows = append(rows, row)
	}

	printTable(rows)

	return nil
}
EOF

goimports -w "${OBJS_NAME}_list_gen.go"
